## 后端

Java21, Spring Boot 3 单体

理由：

1. Java21有虚拟线程，可以做评测任务
2. Spring Boot 3 是对应当前较新的框架

> 不选择 Spring Cloud，避免过度设计。代码按 DDD 分层，现在不做，但保留后续扩展分布式/微服务。

相关生态：

- Spring Security + JWT + RBAC；可以实现 access / refresh 双 token

- MyBatis-Plus

  理由：精细控制，适合优化、用户提交代码可按月分表。

  > 相较 Hibernate 更加学习成本更低、SQL业务编写与性能调优更灵活。不适用 ShardingSphere 分库分表避免过度设计

- Spring WebSocket 双向通信 + SSE 单向通信 + STOMP

  > 答疑等功能需要双向通信；agent回答，判题结果推送等单向

- Maven, Git (Github), IDEA 2025.3

  > 以后可考虑 CI/CD Github Actions

- Docker Compose 部署

  > 无需 Kubernetes，过于复杂

- Knife4j 接口文档，Jakarta Validation 参数校验

- SLF4J + Logback 日志

- Spring Boot Actuator + Prometheus + Grafana 后台监控

- Hutool Captcha 图形验证码

  > 相较 AJ-Captcha，实现更简单，但未来可考虑升级为AJ

- REST API 接口；

  > 相较 GraphQL 而言，REST 更主流；内部通信直接用 HTTP，无需gRPC

## 评测机

go-judge

理由：

1. 支持多语言，SPJ，交互题，时空开销限制，隔离危险操作函数
2. 被多个 OJ 使用，成熟的沙箱，cgroup隔离，API 调用

> 竞品 seccomp 系统调用过滤复杂，维护成本高
>
> 自研工作量巨大，容易出安全漏洞，MVP 阶段暂不考虑

## AI集成

1. Spring AI + OpenAI API 调用多个 LLM

   > 用 langchain4j 也行，代码量少一点，但没必要用这么复杂的场景；这里考虑 Spring 生态方便性使用 Spring AI，认为二者区别不大

2. 向量数据库直接复用 Redis Stack，数据量不大性能足够

   > ① pgvector 是 pg 的，我打算用 MySQL；② Milvus Lite 在 Java SDK 不支持，完整版太重；③ Elasticsearch 不需要使用

## 数据库

MySQL8 + 分表 + MinIO

理由：

1. MySQL 本身是主流关系型数据库，本项目数据建模适合做 ER
2. 与竞品 DomJudge、Socoding OJ 保持一致，方便数据迁移
3. 我运维时至少有 70w+ 提交数据，部分表性能差
4. MinIO 存储测试点、图片、附件

> 不选 PostgreSQL 理由：我更熟悉 MySQL，在此项目背景下二者没有显著的差异

## 缓存

Redis 7

具体应用：

- 图形验证码、JWT Token、评测任务状态、排行榜

- 全局配置、用户登录 Session

- 提交频率限制、分布式锁

  > 限流不用 Guava RateLimiter 的理由：直接用 Redis + Lua 更方便；令牌桶通用性低

- 比赛排行榜(封榜则不更新)

## 消息队列

 RabbitMQ，主要是比赛开始时削峰填谷

1. 支持优先级队列，这是 Kafka, RocketMQ 没有的
2. 支持延迟消息，这是 Kakfa 没有的
3. RabbitMQ 运维复杂度低，轻量，吞吐万级一般够用了，不需要更高的吞吐

解决幂等、确认机制、超时重试。如果不用 MQ，丢消息 (如 Redis Stream/List)。

> 用 RocketMQ 也行，差别不大，但本项目使用 Kafka 不合适

## 前端

Vue3 + Arco Design (或其他) + Monaco Editor 

主要使用 Vibe Coding + skills 实现。

